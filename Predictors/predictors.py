import pandas as pd
import numpy as np
import h2o


from fbprophet import Prophet
from sklearn.metrics import mean_squared_error, mean_absolute_error
from fbprophet.diagnostics import cross_validation, performance_metrics
from h2o.automl import H2OAutoML

from Configuration.config import Config


class ProphetPredictor:
    def __init__(self, df: pd.DataFrame):
        config = Config()
        self.df: pd.DataFrame = df
        self.frequency: str = config.FREQUENCY

    def execute_prophet(self, train_set: pd.DataFrame, test_set: pd.DataFrame):
        train_set = np.log(train_set.set_index('index'))

        # Training Prophet
        model = Prophet(
            growth='linear',
            interval_width=0.85,
            seasonality_mode='additive',
            # Additive if constant trends. Low Stdev from the mean. Less number of trades since commodities do not tend to grow exponentially
            changepoint_prior_scale=5,  # If volatility is high, increase it
            seasonality_prior_scale=10,
            # Try to find a relation between the number of transactions and seasonality -->Mb reject high seasonality (overtrading) if accuracy is low.
            daily_seasonality=False,
            weekly_seasonality=False,
            yearly_seasonality=False
        ).add_seasonality(
            name='monthly',
            period=30.5,
            fourier_order=35  # Detects the waves. The higher the more weights.
        ).add_seasonality(
            name='daily',
            period=1,
            fourier_order=25

        )

        model.fit(train_set.reset_index().rename(columns={'index': 'ds', 'close': 'y'}))

        if len(test_set) > 0:
            print('Training partial dataset and predicting for test length...')
            close_prices_fcast = model.make_future_dataframe(periods=len(test_set), freq=self.frequency)
        else:
            print('Training the whole dataset and predicting for 6 months ahead...')
            close_prices_fcast = model.make_future_dataframe(periods=4700, freq=self.frequency)

        data_fcast = model.predict(close_prices_fcast)
        return data_fcast


class H2oPredictor:

    def __init__(self, df: pd.DataFrame):
        self.df: pd.DataFrame = df
        self.h2o_df = self._create_h2o_df()

    def _create_h2o_df(self):
        h2o_frame = h2o.H2OFrame(self.df)
        h2o_df = h2o_frame.as_data_frame()

        duplicates = list(h2o_df[h2o_df.duplicated()].index)
        if duplicates:
            print('There are duplicated values generated by h2o: ', duplicates)
            h2o_frame = h2o_df.drop(duplicates, axis=0)
        else:
            print('No duplicates autogenerated by h2o')
            
        # Removing columns
        y = 'Label'
        x = h2o_frame.columns
        x.remove(y)
        x.remove('fcal_ts')
        x.remove('lcal_ts')

        h2o_frame[y] = h2o_frame[y].asfactor()

        return x, y, h2o_frame
