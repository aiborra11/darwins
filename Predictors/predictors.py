import empyrical as em
import pandas as pd
import numpy as np
import h2o
import talib
import time
import os
import matplotlib.dates as mdates
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split
from matplotlib.figure import figaspect
from h2o.automl import H2OAutoML
from fbprophet import Prophet
from sklearn.metrics import mean_squared_error, mean_absolute_error
from fbprophet.diagnostics import cross_validation, performance_metrics
from h2o.automl import H2OAutoML



class ProphetPredictor:
    def __init__(self, df: pd.DataFrame):
        self.df: pd.DataFrame = df

    def execute_prophet(train_set: pd.DataFrame, test_Set: pd.DataFrame):
        train_set = np.log(train_set.set_index('index'))

        # Training Prophet
        model = Prophet(
            growth='linear',
            interval_width=0.85,
            seasonality_mode='additive',
            # Additive if constant trends. Low Stdev from the mean. Less number of trades since commodities do not tend to grow exponentially
            changepoint_prior_scale=5,  # If volatility is high, increase it
            seasonality_prior_scale=10,
            # Try to find a relation between the number of transactions and seasonality -->Mb reject high seasonality (overtrading) if accuracy is low.
            daily_seasonality=False,
            weekly_seasonality=False,
            yearly_seasonality=False
        ).add_seasonality(
            name='monthly',
            period=30.5,
            fourier_order=35  # Detects the waves. The higher the more weights.
        ).add_seasonality(
            name='daily',
            period=1,
            fourier_order=25
        )

        model.fit(data_train.reset_index().rename(columns={'index': 'ds', 'close': 'y'}))

        if len(data_test) > 0:
            print('Training partial dataset and predicting for test length...')
            close_prices_fcast = model.make_future_dataframe(periods=len(data_test), freq=frequency)
        else:
            print('Training the whole dataset and predicting for 6 months ahead...')
            close_prices_fcast = model.make_future_dataframe(periods=4700, freq=frequency)

        data_fcast = model.predict(close_prices_fcast)


class H2oPredictor:

    def __init__(self, df: pd.DataFrame):
        self.df: pd.DataFrame = df
        self.h2o_df = self._create_h2o_df()

    def _create_h2o_df(self):
        h2o_frame = h2o.H2OFrame(self.data)
        h2o_df = h2o_frame.as_data_frame()

        duplicates = list(h2o_df[h2o_df.duplicated()].index)
        if duplicates:
            print('There are duplicated values generated by h2o: ', duplicates)
            h2o_frame = h2o_df.drop(duplicates, axis=0)
        else:
            print('No duplicates autogenerated by h2o')
            
        # Removing columns
        y = 'Label'
        x = h2o_frame.columns
        x.remove(y)
        x.remove('fcal_ts')
        x.remove('lcal_ts')

        h2o_frame[y] = h2o_frame[y].asfactor()

        return x, y, h2o_frame