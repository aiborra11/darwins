import pandas as pd
import h2o
import logging

from fbprophet import Prophet

from config import Config


class ProphetPredictor:
    def __init__(self, train_df: pd.DataFrame, test_df: pd.DataFrame):
        config = Config()
        self.train_set: pd.DataFrame = train_df
        self.test_set: pd.DataFrame = test_df

        self.frequency: str = config.TIMEFRAME

    def execute_prophet(self):
        logging.info('Executing PROPHET predictor')

        model = Prophet(
            growth='linear',
            interval_width=0.85,
            seasonality_mode='additive',
            # Additive if constant trends. Low Stdev from the mean. Less number of trades since commodities do not tend to grow exponentially
            changepoint_prior_scale=5,  # If volatility is high, increase it
            seasonality_prior_scale=10,
            # Try to find a relation between the number of transactions and seasonality -->Mb reject high seasonality (overtrading) if accuracy is low.
            daily_seasonality=False,
            weekly_seasonality=False,
            yearly_seasonality=False
        ).add_seasonality(
            name='monthly',
            period=30.5,
            fourier_order=25  # Detects the waves. The higher the more weights.
        ).add_seasonality(
            name='daily',
            period=1,
            fourier_order=35
        )
        model.fit(self.train_set.reset_index().rename(columns={'timestamp': 'ds', 'close': 'y'}))

        if len(self.test_set) > 0:
            logging.info('Training partial dataset and predicting for test length...')
            predicted_periods = model.make_future_dataframe(periods=len(self.test_set), freq=self.frequency)
            print('check', predicted_periods)
        else:
            logging.info('Training the whole dataset and predicting for 6 months ahead...')
            predicted_periods = model.make_future_dataframe(periods=4700, freq=self.frequency)

        data_fcast = model.predict(predicted_periods)

        model.plot(data_fcast).savefig('0.png')
        model.plot_components(data_fcast).savefig('1.png')
        # data_fcast['yhat'] = np.exp(data_fcast['yhat']) if self.log_candles else data_fcast['yhat']

        return data_fcast


class H2oPredictor:
    def __init__(self, df: pd.DataFrame):
        self.df: pd.DataFrame = df
        self.h2o_df = self._create_h2o_df()

    def _create_h2o_df(self):
        h2o_frame = h2o.H2OFrame(self.df)
        h2o_df = h2o_frame.as_data_frame()

        duplicates = list(h2o_df[h2o_df.duplicated()].index)
        if duplicates:
            logging.warning('There are duplicated values generated by h2o: ', duplicates)
            h2o_frame = h2o_df.drop(duplicates, axis=0)
        else:
            logging.info('No duplicates autogenerated by h2o')
            
        # Removing columns
        y = 'Label'
        x = h2o_frame.columns
        x.remove(y)
        x.remove('fcal_ts')
        x.remove('lcal_ts')

        h2o_frame[y] = h2o_frame[y].asfactor()

        return x, y, h2o_frame
